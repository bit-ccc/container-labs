# Docker Storage and Persistence

This chapter explains how Docker manages storage and how you can persist data generated by and used by Docker containers. By default, files you create inside a container are stored in a writable layer, but this data is lost when the container is removed. Understanding Docker's storage mechanisms is crucial for building stateful applications.

For a deep dive, refer to the official storage docs: https://docs.docker.com/storage/.

# What Exactly is a Container?

A Docker container consists of two main parts:

1.  **A Read-Only Image**: This is the blueprint, containing the application and all its dependencies.
2.  **A Writable Container Layer**: A thin read-write layer stacked on top of the image. Any changes made inside the container - creating, modifying, or deleting files - are written to this layer.

When you run `docker commit`, you are essentially creating a new image from the combination of the original image and the container's writable layer.

The container also has a configuration managed by Docker, which includes its name, networking settings, and storage attachments.

## The Ephemeral Nature of Containers

Data in the container's writable layer persists as long as the container exists, even if it's stopped and restarted. However, this data is lost forever when the container is removed (`docker rm`). Let's demonstrate this.

### Step 1: Create a Container and Modify a File

First, let's run an `nginx` container and change its default `index.html` page.

```sh
# Run an nginx container, publishing port 8080
docker run -d --name my-nginx -p 127.0.0.1:8080:80 nginx

# Verify the change by curling localhost:8080 - you may also use a browser if availble
curl http://127.0.0.1:8080

### OUTPUT from curl ###
<!DOCTYPE html>
<html>

# Use docker exec to overwrite the default nginx page
# The command replaces the content of the default page displayed by nginx
docker exec my-nginx /bin/bash -c 'echo "<h1>Hello from my modified container!</h1>" > /usr/share/nginx/html/index.html'

# Verify the change by curling localhost:8080 - you may also use a browser if availble
curl http://127.0.0.1:8080

### OUTPUT from curl ###
<h1>Hello from my modified container!</h1>
```

### Step 2: Restart the Container

Now, let's stop and restart the container. The change will still be there because the writable layer is preserved.

```sh
# Stop and restart the container
docker stop my-nginx
docker start my-nginx

# Verify the change again
curl http://127.0.0.1:8080

### OUTPUT ###
<h1>Hello from my modified container!</h1>
```

### Step 3: Recreate the Container

Now, let's remove the container and create a new one from the same `nginx` image. The modification will be gone because we've discarded the old writable layer.

```sh
# Remove the container
docker rm -f my-nginx

# Run a new container with the same name
docker run -d --name my-nginx -p 127.0.0.1:8080:80 nginx

# Verify the content
curl http://127.0.0.1:8080

### OUTPUT ###
<!DOCTYPE html>
<html>
<head>
<title>Welcome to nginx!</title>
...
```

This demonstrates that to persist data beyond the life of a single container, we need to store it outside the container layer. This is where volumes and bind mounts come in to play.

# Persisting Data with Volumes

Volumes are the recommended way to persist data in Docker. They are managed by Docker itself and are stored in a dedicated area on the host filesystem (e.g., `/var/lib/docker/volumes/` on Linux). There are also various providers for provisioning volumes on external storage like an NFS-Share, but this is out of scope for now.

**Key Features of Volumes:**

- **Decoupled Lifecycle**: Volumes exist independently of containers. They are not automatically removed when a container is removed.
- **Performance**: On Docker Desktop, volumes have much better performance than bind mounts from the host filesystem.
- **Safe to Share**: Multiple containers can safely use the same volume simultaneously.

## Using a Volume

Let's repeat our `nginx` example, but this time, we'll store the `html` directory in a Docker volume.

### Step 1: Create a Volume and a Container

```sh
# Create a Docker volume
docker volume create nginx-data

# Run the nginx container, mounting the volume to the html directory
# The format is -v <volume-name>:<path-in-container>
docker run -d --name persistent-nginx -p 127.0.0.1:8080:80 -v nginx-data:/usr/share/nginx/html nginx
```

When we mount an empty volume into a directory that already contains files in the image (`/usr/share/nginx/html`), Docker copies the image's content into the volume. So our `index.html` is now in the `nginx-data` volume.

### Step 2: Modify the File and Recreate the Container

Let's modify the `index.html` inside the volume and then recreate the container.

```sh
# Modify the index.html
docker exec persistent-nginx /bin/bash -c 'echo "<h1>Hello from a Docker Volume!</h1>" > /usr/share/nginx/html/index.html'

# Verify the change
curl http://127.0.0.1:8080

### OUTPUT ###
<h1>Hello from a Docker Volume!</h1>

# Now, remove and recreate the container, but reuse the SAME volume
docker rm -f persistent-nginx
docker run -d --name persistent-nginx-2 -p 127.0.0.1:8080:80 -v nginx-data:/usr/share/nginx/html nginx

# Check the content again
curl http://127.0.0.1:8080

### OUTPUT ###
<h1>Hello from a Docker Volume!</h1>
```

The data persists! Because the `index.html` file lives in the `nginx-data` volume, it survives the container's removal and is available to the new container.

### Cleaning Up Volumes

You can remove a volume with `docker volume rm nginx-data` and all unused volumes with `docker volume prune`.

# Persisting Data with Bind Mounts

Bind mounts link a file or directory from your host machine directly into a container. When you use a bind mount, the host's file or directory is the source of truthâ€”changes on the host are immediately reflected in the container, and vice-versa. This is often used to link config files or secrets into a container.

**Key Features of Bind Mounts:**

- **Easy Access**: You can edit files directly on your host using your favorite editor.
- **Development Workflow**: Ideal for development when you are actively changing source code.
- **Performance Note**: On Docker Desktop (Mac/Windows), bind mounts can have performance issues compared to volumes.

## Using a Bind Mount

Let's mount a local directory containing our website's `index.html` into the `nginx` container.

### Step 1: Create a Local Directory and File

```sh
# Create a directory for our site content on the host
mkdir ./my-site
echo '<h1>Hello from a Bind Mount!</h1>' > ./my-site/index.html
```

### Step 2: Run the Container with a Bind Mount

The format for a bind mount is `-v /path/on/host:/path/in/container`. We'll use `$(pwd)` to get the absolute path to our current directory.

```sh
# Run nginx, mounting the local directory
docker run -d --name bind-mount-nginx -p 127.0.0.1:8080:80 -v $(pwd)/my-site:/usr/share/nginx/html nginx

# Verify the content
curl http://127.0.0.1:8080

### OUTPUT ###
<h1>Hello from a Bind Mount!</h1>
```

### Step 3: Modify the Host File

Now, change the file on your host machine and see the change reflected in the container instantly, without restarting or recreating anything.

```sh
# Change the file on the host
echo "<h1>Updated on the host!</h1>" > ./my-site/index.html

# Curl the container again
curl http://127.0.0.1:8080

### OUTPUT ###
<h1>Updated on the host!</h1>
```

This direct link makes bind mounts perfect for development workflows where you need to see code changes live.

# In-Memory Storage with tmpfs Mounts

`tmpfs` mounts are temporary and live only in the container's memory. They are useful for storing sensitive data that you don't want to write to disk, or for performance-critical applications that need to avoid disk I/O for temporary files.

**Key Features of `tmpfs`:**

- **Volatile**: Data is completely gone when the container stops.
- **High Performance**: Extremely fast as it's stored in RAM.

## Using a `tmpfs` Mount

Let's mount a `tmpfs` directory and write a file to it. The data will disappear when the container is stopped.

```sh
# Run nginx with a tmpfs mount at /usr/share/nginx/html
docker run -d --name tmpfs-nginx -p 127.0.0.1:8080:80 --tmpfs /usr/share/nginx/html nginx

# Write a file to the tmpfs mount
docker exec tmpfs-nginx /bin/bash -c 'echo "<h1>Hello from tmpfs!</h1>" > /usr/share/nginx/html/index.html'

# Verify the content
curl http://127.0.0.1:8080

### OUTPUT ###
<h1>Hello from tmpfs!</h1>

# Now, stop and restart the container
docker stop tmpfs-nginx
docker start tmpfs-nginx

# Try to access the file again - it will be gone, and you'll get the default nginx page
curl http://127.0.0.1:8080

### OUTPUT ###
<!DOCTYPE html>
<html>
<head>
<title>Welcome to nginx!</title>
...
```

# Summary: Volumes vs. Bind Mounts vs. tmpfs

| Feature           | Volumes                                          | Bind Mounts                       | tmpfs Mounts                                    |
| :---------------- | :----------------------------------------------- | :-------------------------------- | :---------------------------------------------- |
| **Managed by**    | Docker                                           | You (the user)                    | Memory                                          |
| **Host Location** | Docker storage area                              | Anywhere on the host              | RAM                                             |
| **Persistence**   | Persists until deleted                           | Persists until deleted            | Lost when container stops                       |
| **Best For**      | Production data, sharing data between containers | Development, editing code on host | Temporary, sensitive, or high-performance files |
